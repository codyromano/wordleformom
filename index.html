<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Kim's Wordle</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css?v=1.0.9">
</head>
<body>
  <!-- Intro Page -->
  <div class="intro-page" id="introPage">
    <div class="intro-container">
      <h1 class="intro-title">Kim's Wordle</h1>
      <p class="intro-subtitle">Solve a daily Wordle to receive a compliment from your friends.</p>
      
      <div class="avatars-container">
        <div class="avatar"><img src="images/muriel.png" alt="Muriel"></div>
        <div class="avatar"><img src="images/joycie.png" alt="Joycie"></div>
        <div class="avatar"><img src="images/carol.png" alt="Carol"></div>
        <div class="avatar"><img src="images/danae.png" alt="Danae"></div>
        <div class="avatar"><img src="images/sal.png" alt="Sal"></div>
        <div class="avatar"><img src="images/caitlin.png" alt="Caitlin"></div>
        <div class="avatar"><img src="images/brooke.png" alt="Brooke"></div>
        <div class="avatar"><img src="images/cody.png" alt="Cody"></div>
      </div>
      
      <button class="play-button" onclick="startGame()">Play</button>
    </div>
  </div>

  <!-- Main Game -->
  <div class="container" id="mainGame" style="display: none;">
    <div class="tabs">
      <button class="tab-btn active" onclick="switchTab('game')">Play</button>
      <button class="tab-btn" id="complimentsTab" onclick="switchTab('compliments')">
        Compliments
        <span class="tab-notification-bell" id="tabNotificationBadge" style="display: none;">üîî</span>
      </button>
    </div>

    <div class="tab-content" id="gameTab">
      <div class="waiting-message" id="waitingMessage" style="display: none;">
        <div class="waiting-icon">‚è∞</div>
        <h2 class="waiting-title">Come back tomorrow!</h2>
        <p class="waiting-text">You've already completed today's puzzle.</p>
        <p class="waiting-countdown" id="countdown"></p>
      </div>
      <div class="completed-message" id="completedMessage" style="display: none;">
        <div class="completed-icon">üéâ</div>
        <h2 class="completed-title">Congratulations!</h2>
        <p class="completed-text">You've completed all puzzles!</p>
        <p class="completed-subtext">You've unlocked all the wonderful compliments from your friends and family.</p>
        <button class="reset-button" onclick="resetAllPuzzles()">Play Again</button>
      </div>
      <div id="gameContent">
        <div class="board" id="board"></div>
        <div class="message" id="message"></div>
        
        <div class="keyboard" id="keyboard"></div>
      </div>
    </div>

    <div class="tab-content" id="complimentsTabContent" style="display: none;">
      <div class="compliments-list" id="complimentsList"></div>
    </div>
  </div>

  <div class="compliment-modal" id="modal">
    <div class="compliment-content">
      <h2 id="modal-heading">üéâ Today's Word üéâ</h2>
      <p class="compliment-text" id="compliment"></p>
      <p class="compliment-from" id="from"></p>
      <button class="close-btn" onclick="closeModal()">Close</button>
    </div>
  </div>

  <!-- Debug Modal -->
  <div class="debug-modal" id="debugModal">
    <div class="debug-modal-content">
      <div class="debug-modal-header">
        <h2>Debug Tools</h2>
        <button class="debug-close-btn" onclick="closeDebugModal()">√ó</button>
      </div>
      
      <div class="debug-modal-body">
        <div class="debug-section">
        <h3>Current Puzzle</h3>
        <p class="debug-solution" id="debugSolution">‚Äî</p>
      </div>
      
      <div class="debug-section">
        <h3>Time Override</h3>
        <div class="debug-time-controls">
          <button onclick="adjustDebugTime(-24)">-24h</button>
          <button onclick="adjustDebugTime(-12)">-12h</button>
          <button onclick="adjustDebugTime(12)">+12h</button>
          <button onclick="adjustDebugTime(24)">+24h</button>
          <button onclick="resetDebugTime()">Reset</button>
        </div>
        <p class="debug-time-display" id="debugTimeDisplay">No offset</p>
      </div>
      
      <div class="debug-section">
        <h3>Compliments</h3>
        <div class="debug-buttons">
          <button onclick="selectAllCompliments()">Select All</button>
          <button onclick="unselectAllCompliments()">Unselect All</button>
        </div>
        <div class="debug-compliments-list" id="debugComplimentsList"></div>
      </div>
      
      <div class="debug-section">
        <h3>Local Storage</h3>
        <div class="debug-buttons">
          <button onclick="copyLocalStorageToClipboard()">Copy to Clipboard</button>
        </div>
        <p class="debug-info" id="copyStatus" style="display: none; margin-top: 8px; color: #4caf50; font-size: 14px;"></p>
      </div>
      </div>
    </div>
  </div>

  <div class="version-number" id="versionNumber">v1.0.9</div>

  <script src="puzzles.js"></script>
  <script>
    // Debug modal functions (defined first so onclick handlers work)
    function openDebugModal() {
      const modal = document.getElementById('debugModal');
      modal.classList.add('show');
      
      // Update current solution
      const targetWord = typeof TARGET_WORD !== 'undefined' ? TARGET_WORD : 'No puzzle loaded';
      document.getElementById('debugSolution').textContent = targetWord;
      
      // Update time display
      updateDebugTimeDisplay();
      
      // Load compliments list
      loadDebugComplimentsList();
    }
    
    function closeDebugModal() {
      const modal = document.getElementById('debugModal');
      modal.classList.remove('show');
    }
    
    function adjustDebugTime(hours) {
      const currentOffset = parseInt(localStorage.getItem('debugTimeOffset') || '0');
      const newOffset = currentOffset + (hours * 60 * 60 * 1000);
      localStorage.setItem('debugTimeOffset', newOffset.toString());
      updateDebugTimeDisplay();
    }
    
    function resetDebugTime() {
      localStorage.removeItem('debugTimeOffset');
      updateDebugTimeDisplay();
      setTimeout(() => window.location.reload(), 500);
    }
    
    function updateDebugTimeDisplay() {
      const offset = parseInt(localStorage.getItem('debugTimeOffset') || '0');
      const display = document.getElementById('debugTimeDisplay');
      if (offset === 0) {
        display.textContent = 'No offset';
      } else {
        const hours = offset / (1000 * 60 * 60);
        display.textContent = `Offset: ${hours > 0 ? '+' : ''}${hours}h`;
      }
    }
    
    function loadDebugComplimentsList() {
      const savedCompliments = getCompliments();
      const listEl = document.getElementById('debugComplimentsList');
      
      // Create a map of saved compliments for quick lookup
      const savedMap = {};
      savedCompliments.forEach(c => {
        savedMap[c.word] = c.unread;
      });
      
      // Show all puzzles from dailyPuzzles array
      listEl.innerHTML = dailyPuzzles.map((puzzle, index) => {
        const isSeen = savedMap.hasOwnProperty(puzzle.word) && !savedMap[puzzle.word];
        const isUnlocked = savedMap.hasOwnProperty(puzzle.word);
        
        return `
          <div class="debug-compliment-item ${!isUnlocked ? 'locked' : ''}">
            <label>
              <input type="checkbox" 
                     ${isSeen ? 'checked' : ''}
                     onchange="toggleComplimentSeenByWord('${puzzle.word}', this.checked)">
              <span>${puzzle.word} - ${puzzle.from}${!isUnlocked ? ' üîí' : ''}</span>
            </label>
          </div>
        `;
      }).join('');
    }
    
    function toggleComplimentSeenByWord(word, isSeen) {
      const compliments = getCompliments();
      const complimentIndex = compliments.findIndex(c => c.word === word);
      const solvedPuzzles = getSolvedPuzzles();
      const solvedIndex = solvedPuzzles.findIndex(p => p.word === word);
      
      if (isSeen) {
        // Checking the box - mark as seen and solved
        if (complimentIndex >= 0) {
          compliments[complimentIndex].unread = false;
        } else {
          // Create the compliment if it doesn't exist yet and mark as seen
          const puzzle = dailyPuzzles.find(p => p.word === word);
          if (puzzle) {
            compliments.push({
              word: puzzle.word,
              compliment: puzzle.compliment,
              from: puzzle.from,
              date: new Date().toISOString().split('T')[0],
              unread: false
            });
          }
        }
        
        // Also mark as solved if not already
        if (solvedIndex < 0) {
          solvedPuzzles.push({
            word: word,
            date: getTodayString(),
            won: true
          });
        }
      } else {
        // Unchecking the box - remove from compliments and solved puzzles
        if (complimentIndex >= 0) {
          compliments.splice(complimentIndex, 1);
        }
        if (solvedIndex >= 0) {
          solvedPuzzles.splice(solvedIndex, 1);
        }
      }
      
      localStorage.setItem('compliments', JSON.stringify(compliments));
      localStorage.setItem('solvedPuzzles', JSON.stringify(solvedPuzzles));
      updateNotificationBadge();
    }
    
    function selectAllCompliments() {
      dailyPuzzles.forEach(puzzle => {
        toggleComplimentSeenByWord(puzzle.word, true);
      });
      loadDebugComplimentsList();
    }
    
    function unselectAllCompliments() {
      dailyPuzzles.forEach(puzzle => {
        toggleComplimentSeenByWord(puzzle.word, false);
      });
      // Also clear lastPlayedDate so user can play immediately
      localStorage.removeItem('lastPlayedDate');
      loadDebugComplimentsList();
    }
    
    function copyLocalStorageToClipboard() {
      const statusEl = document.getElementById('copyStatus');
      
      try {
        // Create an object with all localStorage data, parsing JSON where applicable
        const localStorageData = {};
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          const value = localStorage.getItem(key);
          
          // Try to parse JSON values for better readability
          try {
            localStorageData[key] = JSON.parse(value);
          } catch {
            // If not JSON, store as-is
            localStorageData[key] = value;
          }
        }
        
        // Convert to formatted JSON with proper indentation
        const jsonString = JSON.stringify(localStorageData, null, 2);
        
        // Try modern clipboard API first
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(jsonString).then(() => {
            statusEl.textContent = '‚úì Copied to clipboard!';
            statusEl.style.color = '#4caf50';
            statusEl.style.display = 'block';
            
            setTimeout(() => {
              statusEl.style.display = 'none';
            }, 3000);
          }).catch(err => {
            // Fallback if clipboard API fails
            fallbackCopy(jsonString, statusEl);
          });
        } else {
          // Use fallback for older browsers/mobile
          fallbackCopy(jsonString, statusEl);
        }
      } catch (err) {
        statusEl.textContent = '‚úó Error: ' + err.message;
        statusEl.style.color = '#f44336';
        statusEl.style.display = 'block';
        
        setTimeout(() => {
          statusEl.style.display = 'none';
          statusEl.style.color = '#4caf50';
        }, 5000);
      }
    }
    
    function fallbackCopy(text, statusEl) {
      try {
        // Create a temporary textarea
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.top = '0';
        textarea.style.left = '0';
        textarea.style.width = '2em';
        textarea.style.height = '2em';
        textarea.style.padding = '0';
        textarea.style.border = 'none';
        textarea.style.outline = 'none';
        textarea.style.boxShadow = 'none';
        textarea.style.background = 'transparent';
        document.body.appendChild(textarea);
        
        // Select and copy
        textarea.focus();
        textarea.select();
        textarea.setSelectionRange(0, text.length);
        
        const successful = document.execCommand('copy');
        document.body.removeChild(textarea);
        
        if (successful) {
          statusEl.textContent = '‚úì Copied to clipboard!';
          statusEl.style.color = '#4caf50';
          statusEl.style.display = 'block';
          
          setTimeout(() => {
            statusEl.style.display = 'none';
          }, 3000);
        } else {
          statusEl.textContent = '‚úó Copy failed - try manually selecting the text';
          statusEl.style.color = '#f44336';
          statusEl.style.display = 'block';
          
          setTimeout(() => {
            statusEl.style.display = 'none';
            statusEl.style.color = '#4caf50';
          }, 5000);
        }
      } catch (err) {
        statusEl.textContent = '‚úó Copy not supported on this browser';
        statusEl.style.color = '#f44336';
        statusEl.style.display = 'block';
        
        setTimeout(() => {
          statusEl.style.display = 'none';
          statusEl.style.color = '#4caf50';
        }, 5000);
      }
    }

    // Debug time functions (must be defined first)
    function getDebugTimeOffset() {
      return parseInt(localStorage.getItem('debugTimeOffset') || '0');
    }

    function getDebugAdjustedDate() {
      const offset = getDebugTimeOffset();
      return new Date(Date.now() + offset);
    }

    // Start game function
    function startGame() {
      document.getElementById('introPage').style.display = 'none';
      document.getElementById('mainGame').style.display = 'flex';
      
      if (!canPlayToday()) {
        // Show waiting message instead of game
        showWaitingMessage();
      }
    }

    // Format and display current date
    function formatDate() {
      const now = getDebugAdjustedDate();
      const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
      
      const dayName = days[now.getDay()];
      const monthName = months[now.getMonth()];
      const date = now.getDate();
      
      // Add ordinal suffix
      let suffix = 'th';
      if (date === 1 || date === 21 || date === 31) suffix = 'st';
      else if (date === 2 || date === 22) suffix = 'nd';
      else if (date === 3 || date === 23) suffix = 'rd';
      
      return `${dayName}, ${monthName} ${date}${suffix}`;
    }

    // Start game function
    function startGame() {
      document.getElementById('introPage').style.display = 'none';
      document.getElementById('mainGame').style.display = 'flex';
      
      // Check if all puzzles completed
      if (areAllPuzzlesCompleted()) {
        showCompletedMessage();
        return;
      }
      
      if (!canPlayToday()) {
        // Show waiting message instead of game
        showWaitingMessage();
      }
    }

    // LocalStorage functions for puzzle tracking
    function getSolvedPuzzles() {
      const saved = localStorage.getItem('solvedPuzzles');
      return saved ? JSON.parse(saved) : [];
    }

    function getLastPlayedDate() {
      return localStorage.getItem('lastPlayedDate');
    }

    function getTodayString() {
      const today = getDebugAdjustedDate();
      return today.toISOString().split('T')[0];
    }

    function canPlayToday() {
      const lastPlayed = getLastPlayedDate();
      const today = getTodayString();
      return !lastPlayed || lastPlayed !== today;
    }

    function getFirstUnsolvedPuzzle() {
      const solvedPuzzles = getSolvedPuzzles();
      const solvedWords = new Set(solvedPuzzles.map(p => p.word));
      
      for (let puzzle of dailyPuzzles) {
        if (!solvedWords.has(puzzle.word)) {
          return puzzle;
        }
      }
      // All puzzles solved
      return null;
    }

    function saveSolvedPuzzle(word, won) {
      const solvedPuzzles = getSolvedPuzzles();
      const today = getTodayString();
      
      // Check if already saved
      const exists = solvedPuzzles.some(p => p.word === word && p.date === today);
      if (!exists) {
        solvedPuzzles.push({
          word: word,
          date: today,
          won: won
        });
        localStorage.setItem('solvedPuzzles', JSON.stringify(solvedPuzzles));
        localStorage.setItem('lastPlayedDate', today);
      }
    }

    function areAllPuzzlesCompleted() {
      const solvedPuzzles = getSolvedPuzzles();
      const solvedWords = new Set(solvedPuzzles.map(p => p.word));
      return dailyPuzzles.every(puzzle => solvedWords.has(puzzle.word));
    }

    function showCompletedMessage() {
      document.getElementById('completedMessage').style.display = 'flex';
      document.getElementById('gameContent').style.display = 'none';
      document.getElementById('waitingMessage').style.display = 'none';
    }

    function resetAllPuzzles() {
      if (confirm('Are you sure you want to reset all puzzles? This will clear your progress and compliments.')) {
        localStorage.removeItem('solvedPuzzles');
        localStorage.removeItem('lastPlayedDate');
        localStorage.removeItem('compliments');
        window.location.reload();
      }
    }

    // Get today's puzzle (first unsolved or wait for tomorrow)
    const todaysPuzzle = getFirstUnsolvedPuzzle();
    const TARGET_WORD = todaysPuzzle ? todaysPuzzle.word : '';
    const MAX_GUESSES = 6;

    let currentRow = 0;
    let currentTile = 0;
    let gameOver = false;
    const guesses = [];
    const keyStates = {};

    // Create board
    const board = document.getElementById('board');
    for (let i = 0; i < MAX_GUESSES; i++) {
      const row = document.createElement('div');
      row.className = 'row';
      for (let j = 0; j < 5; j++) {
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.id = `tile-${i}-${j}`;
        row.appendChild(tile);
      }
      board.appendChild(row);
    }

    // Create keyboard
    const keyboard = document.getElementById('keyboard');
    const rows = [
      ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
      ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
      ['ENTER', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '‚å´']
    ];

    rows.forEach(row => {
      const rowDiv = document.createElement('div');
      rowDiv.className = 'keyboard-row';
      row.forEach(key => {
        const keyBtn = document.createElement('button');
        keyBtn.className = 'key';
        keyBtn.textContent = key;
        keyBtn.id = `key-${key}`;
        if (key === '‚å´' || key === 'ENTER') {
          keyBtn.classList.add('wide');
        }
        keyBtn.onclick = () => handleKey(key);
        rowDiv.appendChild(keyBtn);
      });
      keyboard.appendChild(rowDiv);
    });

    function handleKey(key) {
      if (gameOver) return;

      if (key === '‚å´') {
        deleteLetter();
      } else if (key === 'ENTER') {
        submitGuess();
      } else if (currentTile < 5) {
        addLetter(key);
      }
    }

    function addLetter(letter) {
      if (currentTile < 5) {
        const tile = document.getElementById(`tile-${currentRow}-${currentTile}`);
        tile.textContent = letter;
        tile.classList.add('filled');
        currentTile++;
      }
    }

    function deleteLetter() {
      if (currentTile > 0) {
        currentTile--;
        const tile = document.getElementById(`tile-${currentRow}-${currentTile}`);
        tile.textContent = '';
        tile.classList.remove('filled');
      }
    }

    function submitGuess() {
      if (currentTile !== 5) {
        showMessage('Not enough letters');
        return;
      }

      const guess = [];
      for (let i = 0; i < 5; i++) {
        const tile = document.getElementById(`tile-${currentRow}-${i}`);
        guess.push(tile.textContent);
      }
      const guessWord = guess.join('');
      guesses.push(guessWord);

      // Check guess
      const result = checkGuess(guessWord);
      animateRow(currentRow, result, guessWord);

      if (guessWord === TARGET_WORD) {
        gameOver = true;
        setTimeout(() => {
          showCompliment();
        }, 2000);
      } else if (currentRow === MAX_GUESSES - 1) {
        gameOver = true;
        setTimeout(() => {
          showCompliment();
        }, 2000);
      } else {
        currentRow++;
        currentTile = 0;
      }
    }

    function checkGuess(guess) {
      const result = [];
      const targetLetters = TARGET_WORD.split('');
      const guessLetters = guess.split('');
      const used = new Array(5).fill(false);

      // Check for correct positions
      for (let i = 0; i < 5; i++) {
        if (guessLetters[i] === targetLetters[i]) {
          result[i] = 'correct';
          used[i] = true;
        }
      }

      // Check for present letters
      for (let i = 0; i < 5; i++) {
        if (result[i]) continue;
        
        let found = false;
        for (let j = 0; j < 5; j++) {
          if (!used[j] && guessLetters[i] === targetLetters[j]) {
            result[i] = 'present';
            used[j] = true;
            found = true;
            break;
          }
        }
        
        if (!found) {
          result[i] = 'absent';
        }
      }

      return result;
    }

    function animateRow(row, result, guess) {
      for (let i = 0; i < 5; i++) {
        setTimeout(() => {
          const tile = document.getElementById(`tile-${row}-${i}`);
          tile.classList.add(result[i]);
          
          const letter = guess[i];
          const keyEl = document.getElementById(`key-${letter}`);
          
          if (!keyStates[letter] || 
              (keyStates[letter] === 'absent' && result[i] !== 'absent') ||
              (keyStates[letter] === 'present' && result[i] === 'correct')) {
            keyStates[letter] = result[i];
            keyEl.classList.remove('absent', 'present', 'correct');
            keyEl.classList.add(result[i]);
          }
        }, i * 300);
      }
    }

    function showMessage(msg) {
      const messageEl = document.getElementById('message');
      messageEl.textContent = msg;
      setTimeout(() => {
        messageEl.textContent = '';
      }, 2000);
    }

    function showCompliment() {
      const won = guesses[guesses.length - 1] === TARGET_WORD;
      document.getElementById('modal-heading').textContent = `üéâ Today's Word: ${TARGET_WORD} üéâ`;
      document.getElementById('compliment').textContent = todaysPuzzle.compliment;
      document.getElementById('from').textContent = todaysPuzzle.from;
      document.getElementById('modal').classList.add('show');
      createSnowflakes();
      
      // Save compliment to local storage
      saveCompliment(TARGET_WORD, todaysPuzzle.compliment, todaysPuzzle.from);
      
      // Save solved puzzle
      saveSolvedPuzzle(TARGET_WORD, won);
    }

    function closeModal() {
      document.getElementById('modal').classList.remove('show');
      
      // Check if all puzzles completed first
      if (areAllPuzzlesCompleted()) {
        showCompletedMessage();
      } else if (canPlayToday()) {
        // Still can play today, reload to get next puzzle
        window.location.reload();
      } else {
        // Show waiting message
        showWaitingMessage();
      }
    }

    // Local storage functions
    function saveCompliment(word, compliment, from) {
      const compliments = getCompliments();
      const today = new Date().toISOString().split('T')[0];
      
      // Check if already saved for today
      const exists = compliments.some(c => c.word === word);
      if (!exists) {
        compliments.push({
          word: word,
          compliment: compliment,
          from: from,
          date: today,
          unread: true
        });
        localStorage.setItem('compliments', JSON.stringify(compliments));
        updateNotificationBadge();
      }
    }

    function getCompliments() {
      const saved = localStorage.getItem('compliments');
      return saved ? JSON.parse(saved) : [];
    }

    function updateNotificationBadge() {
      const compliments = getCompliments();
      const unreadCount = compliments.filter(c => c.unread).length;
      const badge = document.getElementById('tabNotificationBadge');
      
      if (unreadCount > 0) {
        badge.style.display = 'block';
      } else {
        badge.style.display = 'none';
      }
    }

    function markAllAsRead() {
      const compliments = getCompliments();
      compliments.forEach(c => c.unread = false);
      localStorage.setItem('compliments', JSON.stringify(compliments));
      updateNotificationBadge();
    }

    function switchTab(tabName) {
      // Update tab buttons
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      // Update tab content
      if (tabName === 'game') {
        document.getElementById('gameTab').style.display = 'block';
        document.getElementById('complimentsTabContent').style.display = 'none';
      } else if (tabName === 'compliments') {
        document.getElementById('gameTab').style.display = 'none';
        document.getElementById('complimentsTabContent').style.display = 'block';
        loadComplimentsList();
        markAllAsRead();
      }
    }

    function loadComplimentsList() {
      const compliments = getCompliments();
      const listEl = document.getElementById('complimentsList');
      
      if (compliments.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">No compliments yet! Keep playing to unlock them. ‚ù§Ô∏è</p>';
      } else {
        listEl.innerHTML = compliments.reverse().map(c => {
          const date = new Date(c.date);
          const formattedDate = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
          
          return `
            <div class="compliment-card">
              <div class="compliment-card-word">${c.word}</div>
              <div class="compliment-card-text">${c.compliment}</div>
              <div class="compliment-card-from">${c.from}</div>
              <div class="compliment-card-date">${formattedDate}</div>
            </div>
          `;
        }).join('');
      }
    }

    // Initialize notification badge on page load
    updateNotificationBadge();

    // Show waiting message when puzzle already completed today
    function showWaitingMessage() {
      document.getElementById('waitingMessage').style.display = 'flex';
      document.getElementById('gameContent').style.display = 'none';
      updateCountdown();
      setInterval(updateCountdown, 1000);
    }

    function updateCountdown() {
      const now = getDebugAdjustedDate();
      const nextMidnight = new Date(now);
      nextMidnight.setHours(24, 0, 0, 0);
      
      const diff = nextMidnight - now;
      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((diff % (1000 * 60)) / 1000);
      
      const countdownEl = document.getElementById('countdown');
      if (countdownEl) {
        countdownEl.textContent = `Next puzzle in ${hours}h ${minutes}m ${seconds}s`;
      }
    }

    function createSnowflakes() {
      for (let i = 0; i < 30; i++) {
        setTimeout(() => {
          const snowflake = document.createElement('div');
          snowflake.className = 'snowflake';
          snowflake.textContent = '‚ùÑ';
          snowflake.style.left = Math.random() * 100 + '%';
          snowflake.style.animationDuration = (Math.random() * 3 + 2) + 's';
          snowflake.style.opacity = Math.random() * 0.6 + 0.4;
          document.body.appendChild(snowflake);
          
          setTimeout(() => snowflake.remove(), 5000);
        }, i * 100);
      }
    }

    // Keyboard support
    document.addEventListener('keydown', (e) => {
      if (gameOver) return;
      
      if (e.key === 'Enter') {
        handleKey('ENTER');
      } else if (e.key === 'Backspace') {
        handleKey('‚å´');
      } else if (/^[a-zA-Z]$/.test(e.key)) {
        handleKey(e.key.toUpperCase());
      }
    });

    // Attach debug modal listener to version number
    document.getElementById('versionNumber').addEventListener('click', openDebugModal);
  </script>
</body>
</html>